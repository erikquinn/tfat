import Aircraft from './Aircraft.js';
import { DESTINATION_GROUP } from '../constants/clientConstants.js';
import { generateDateFromVatsimTimestamp } from '../../server/serverUtilities.js';

/**
 * A collection of multiple `Aircraft`
 *
 * @class AircraftCollection
 */
export default class AircraftCollection {
    /**
     * Constructor for `AircraftCollection`
     *
     * @for AircraftCollection
     * @constructor
     * @chainable
     */
    constructor(organizationCollection) {
        /**
         * An array containing all `Aircraft` received from the VATSIM data download
         *
         * @for AircraftCollection
         * @property _list
         * @type <array<Aircraft>>
         * @private
         */
        this._list = [];

        /**
         * Metadata describing the details of the data last received from the server
         *
         * @for AircraftCollection
         * @property _metaData
         * @type {object}
         * @private
         */
        this._metaData = {
            /**
             * Time the stored pilot data was generated by the VATSIM servers
             *
             * @for AircraftCollection
             * @memberof _metaData
             * @property updateTime
             * @type {number}
             * @private
             */
            updateTime: 0,

            /**
             * Time the stored pilot data was generated by the VATSIM servers, as a JS `Date` object
             * For the raw value provided by VATSIM data, see `this._metaData.updateTime`
             *
             * @for AircraftCollection
             * @memberof _metaData
             * @property updateTimeObj
             * @type {Date}
             * @private
             */
            updateTimeObj: null,

            /**
             * Total number of pilot connections in the latest data received from VATSIM
             *
             * @for AircraftCollection
             * @memberof _metaData
             * @property pilotConnections
             * @type {number}
             * @private
             */
            pilotConnections: 0,

            /**
             * Total number of connections (of any type) in the latest data received from VATSIM
             *
             * @for AircraftCollection
             * @memberof _metaData
             * @property totalConnections
             * @type {number}
             * @private
             */
            totalConnections: 0
        };

        /**
         * Local reference to the `OrganizationCollection`, used to generate sector boundary waypoints
         *
         * @for AircraftCollection
         * @property _organizationCollection
         * @type {organizationCollection}
         * @private
         */
        this._organizationCollection = organizationCollection;

        return this;
    }

    /**
     * Number of `Aircraft` in the collection
     *
     * @for AircraftCollection
     * @property length
     * @type {number}
     */
    get length() {
        return this._list.length;
    }

    /**
     * Array of `Aircraft` in the collection
     *
     * @for AircraftCollection
     * @property list
     * @type {array<Aircraft>}
     */
    get list() {
        return this._list;
    }

    /**
     * Total number of `Aircraft` in the collection
     *
     * @for AircraftCollection
     * @property totalAircraft
     * @type {number}
     */
    get totalAircraft() {
        return this._list.length;
    }

    /**
     * Public getter for read-only access to `this._metaData.updateTime`
     *
     * @for AircaftCollection
     * @property updateTime
     * @type {number}
     */
    get updateTime() {
        return this._metaData.updateTime;
    }

    /**
     * Return an `AircraftCollection` including all `Aircraft` landing at the specified destination
     *
     * @for AircraftCollection
     * @method filterByDestination
     * @param {string} destination - ICAO identifier of the destination airport to filter by
     * @returns {AircraftCollection}
     */
    filterByDestination(destination) {
        destination = destination.toUpperCase();

        const aircraftList = this._list.filter((ac) => ac.destination === destination);
        const filteredAircraftCollection = this.generateNewCollectionWithAircraft(aircraftList);

        return filteredAircraftCollection;
    }

    /**
     * Return an `AircraftCollection` including all `Aircraft` landing at any of the specified destinations
     *
     * @for AircraftCollection
     * @method filterByDestination
     * @param {array<string>} destinationList - array of ICAO identifiers of the destination airports to filter by
     * @returns {AircraftCollection}
     */
    filterByDestinations(destinationList) {
        const aircraftList = [];

        for (const destination of destinationList) {
            const list = this._list.filter((ac) => ac.destination.toUpperCase() === destination);

            aircraftList.push(...list);
        }

        const filteredAircraftCollection = this.generateNewCollectionWithAircraft(aircraftList);

        return filteredAircraftCollection;
    }

    /**
     * Return an `AircraftCollection` including all `Aircraft` landing at any
     * destination included within the specified destination group
     *
     * @for AircraftCollection
     * @method filterByDestinationGroup
     * @param {string} destination - name of the destination group to filter by, from `DESTINATION_GROUP`
     * @returns {AircraftCollection}
     */
    filterByDestinationGroup(destinationGroupName) {
        destinationGroupName = destinationGroupName.toUpperCase();

        if (!(destinationGroupName in DESTINATION_GROUP)) {
            console.warn(`Invalid filter group specified: "${destinationGroupName}"`);

            return this;
        }

        const airportList = DESTINATION_GROUP[destinationGroupName];
        const aircraftList = this._list.filter((ac) => airportList.includes(ac.destination));
        const filteredAircraftCollection = this.generateNewCollectionWithAircraft(aircraftList);

        return filteredAircraftCollection;
    }

    /**
     * Return a new `AircraftCollection` instance from `this`, containing only the `Aircraft` provided
     *
     * @for AircraftCollection
     * @method generateNewCollectionWithAircraft
     * @param {array<Aircraft>} aircraftList - An array of `Aircraft` instances (NOT VATSIM DATA!) from
     *                                         which to form a new `AircraftCollection`
     * @returns {AircraftCollection}
     */
    generateNewCollectionWithAircraft(aircraftList) {
        const nextAircraftCollection = new AircraftCollection(this._organizationCollection);
        nextAircraftCollection._list = aircraftList;
        nextAircraftCollection._metaData = this._metaData;

        return nextAircraftCollection;
    }

    /**
     * Return an array of objects which each include a `Waypoint` an `Aircraft`
     * passes on its `Route` where they enter or exit a `Sector`
     *
     * @for AircraftCollection
     * @method getSectorChanges
     * @returns {array<object>} - [ {aircraft, waypoint}, {aircraft, waypoint}, ...]
     */
    getSectorChanges() {
        const sectorChanges = [];

        for (const aircraft of this._list) {
            const waypoints = aircraft.route.getWaypointsWithSectorChanges();
            const sectorChangeList = waypoints.map((waypoint) => { return { aircraft, waypoint }; });

            sectorChanges.push(...sectorChangeList);
        }

        return sectorChanges;
    }

    /**
     * Return html table body data for the entry for all `Aircraft` in `this` collection
     *
     * @for AircraftCollection
     * @method getTableBodyHTML
     * @returns {string} - can be directly used with .innerHtml() to create a table body
     */
    getTableBodyHTML() {
        const tableRows = this._list.map((ac) => ac.getTableRowHtml());
        const tableBody = tableRows.join('');

        return tableBody;
    }

    /**
     * Sort all aircraft in the collection by their ETA at their destination
     *
     * This is most useful when using `AircraftCollection.filterByDestination(icao).sortByEta()` to get
     * an AircraftCollection containing only aircraft bound for a particular destination, sorted by ETA
     *
     * @for AircraftCollection
     * @method sortByEta
     * @returns {AircraftCollection} - `this` AircraftCollection instance
     * @chainable
     */
    sortByEta() {
        this._list.sort((aircraft1, aircraft2) => aircraft1.eta - aircraft2.eta);

        return this;
    }

    /**
     * Fill the `AircraftCollection` with `Aircraft` generated from the provided data
     *
     * @for AircraftCollection
     * @method updateCollection
     * @param {object} - in the shape of `{ downloadedData, metaData }`, where...
     *                   downloadedData `{array<object>}` - raw download data from the server (NOT `Aircraft` INSTANCES!)
     *                   metaData `{object}` - information on the latest download (generated time, connection counts, etc)
     * @returns {undefined}
     */
    updateCollection({ data: downloadedData, metaData }) {
        if (!Array.isArray(downloadedData) || downloadedData.length === 0) {
            throw new TypeError(`Download data invalid! Received: ${downloadedData}`);
        }

        if (!(typeof metaData === 'object') || !metaData.updateTime) {
            throw new TypeError(`Download metadata invalid! Received: ${metaData}`);
        }

        metaData.updateTimeObj = new Date(generateDateFromVatsimTimestamp(metaData.updateTime));
        const nextList = [];

        for (const aircraftData of downloadedData) {
            if (!aircraftData) {
                console.error(`Error reading aircraft data: ${aircraftData}`);

                continue;
            }

            const aircraftModel = new Aircraft(aircraftData, metaData.updateTimeObj, this._organizationCollection);

            nextList.push(aircraftModel);
        }

        this._list = nextList;
        this._metaData = metaData;
    }
}
